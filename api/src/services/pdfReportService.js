const PDFDocument = require('pdfkit');
const fs = require('fs');
const path = require('path');
const { format } = require('date-fns');
const prisma = require('../lib/prisma');
const { logger } = require('../utils/logger');

class PDFReportService {
  constructor() {
    this.pageWidth = 612; // Letter size
    this.pageHeight = 792;
    this.margin = 50;
  }

  /**
   * Generate a PDF report
   * @param {Object} report - Report data from database
   * @param {Object} options - Generation options
   * @returns {Promise<Buffer>} PDF buffer
   */
  async generatePDF(report, options = {}) {
    return new Promise(async (resolve, reject) => {
      try {
        // Create PDF document
        const doc = new PDFDocument({
          size: 'letter',
          margins: {
            top: this.margin,
            bottom: this.margin,
            left: this.margin,
            right: this.margin
          },
          info: {
            Title: report.title,
            Author: 'FSW Iron Task',
            Subject: `${report.reportType} Report`,
            Keywords: 'construction,documentation,steel',
            CreationDate: new Date()
          }
        });

        // Collect PDF chunks
        const chunks = [];
        doc.on('data', chunk => chunks.push(chunk));
        doc.on('end', () => resolve(Buffer.concat(chunks)));

        // Get project and company details
        const project = await prisma.project.findUnique({
          where: { id: report.projectId },
          include: {
            company: true,
            projectMembers: {
              include: { user: true }
            }
          }
        });

        // Get report user
        const user = await prisma.user.findUnique({
          where: { id: report.userId }
        });

        // Add header
        this.addHeader(doc, project, report);

        // Add project info section
        this.addProjectInfo(doc, project, report);

        // Add content based on report type
        switch (report.reportType) {
          case 'PROGRESS_RECAP':
            await this.addProgressRecapContent(doc, report, project);
            break;
          case 'SUMMARY':
            await this.addSummaryContent(doc, report, project);
            break;
          case 'DAILY_LOG':
            await this.addDailyLogContent(doc, report, project);
            break;
        }

        // Add footer on each page
        this.addFooter(doc, project);

        // Finalize PDF
        doc.end();
      } catch (error) {
        logger.error('Failed to generate PDF:', error);
        reject(error);
      }
    });
  }

  /**
   * Add header to PDF
   */
  addHeader(doc, project, report) {
    // Company logo placeholder
    doc.rect(this.margin, this.margin, 80, 40).stroke();
    doc.fontSize(10).text('LOGO', this.margin + 30, this.margin + 15);

    // Company name and report title
    doc.fontSize(20)
       .text(project.company.name, 150, this.margin, { width: 400, align: 'center' });
    
    doc.fontSize(16)
       .text(report.title, 150, this.margin + 25, { width: 400, align: 'center' });

    // Line separator
    doc.moveTo(this.margin, this.margin + 60)
       .lineTo(this.pageWidth - this.margin, this.margin + 60)
       .stroke();

    doc.moveDown(3);
  }

  /**
   * Add project information section
   */
  addProjectInfo(doc, project, report) {
    const y = doc.y;
    
    doc.fontSize(14).font('Helvetica-Bold').text('Project Information', this.margin, y);
    doc.moveDown(0.5);

    const infoY = doc.y;
    doc.fontSize(10).font('Helvetica');

    // Left column
    doc.text(`Project: ${project.name}`, this.margin, infoY);
    doc.text(`Job Number: ${project.jobNumber}`, this.margin, infoY + 15);
    doc.text(`Location: ${project.location}`, this.margin, infoY + 30);
    
    // Right column
    doc.text(`Status: ${project.status}`, 300, infoY);
    doc.text(`Report Date: ${format(new Date(report.createdAt), 'MM/dd/yyyy')}`, 300, infoY + 15);
    doc.text(`Generated By: ${report.user?.name || 'System'}`, 300, infoY + 30);

    doc.y = infoY + 50;
    
    // Line separator
    doc.moveTo(this.margin, doc.y)
       .lineTo(this.pageWidth - this.margin, doc.y)
       .stroke();
    
    doc.moveDown(2);
  }

  /**
   * Add progress recap content
   */
  async addProgressRecapContent(doc, report, project) {
    doc.fontSize(14).font('Helvetica-Bold').text('Progress Overview', this.margin, doc.y);
    doc.moveDown(0.5);
    doc.fontSize(10).font('Helvetica');

    // Get media stats
    const mediaStats = await this.getMediaStats(report.projectId, report.metadata?.dateRange);
    
    doc.text(`Total Photos: ${mediaStats.photos}`, this.margin);
    doc.text(`Total Videos: ${mediaStats.videos}`, this.margin);
    doc.text(`Team Members Active: ${mediaStats.activeUsers}`, this.margin);
    doc.moveDown();

    // Activities summary
    if (report.metadata?.activities) {
      doc.fontSize(12).font('Helvetica-Bold').text('Activities Summary', this.margin);
      doc.moveDown(0.5);
      doc.fontSize(10).font('Helvetica');

      for (const activity of report.metadata.activities) {
        doc.text(`• ${activity.type}: ${activity.count} items`, this.margin + 10);
      }
      doc.moveDown();
    }

    // Key accomplishments
    if (report.content?.accomplishments) {
      doc.fontSize(12).font('Helvetica-Bold').text('Key Accomplishments', this.margin);
      doc.moveDown(0.5);
      doc.fontSize(10).font('Helvetica');

      const accomplishments = report.content.accomplishments.split('\n');
      for (const item of accomplishments) {
        if (item.trim()) {
          doc.text(`• ${item.trim()}`, this.margin + 10);
        }
      }
      doc.moveDown();
    }

    // Safety notes
    if (report.content?.safetyNotes) {
      doc.fontSize(12).font('Helvetica-Bold').text('Safety Notes', this.margin);
      doc.moveDown(0.5);
      doc.fontSize(10).font('Helvetica');
      doc.text(report.content.safetyNotes, this.margin + 10);
      doc.moveDown();
    }

    // Media section
    await this.addMediaSection(doc, report);
  }

  /**
   * Add summary content
   */
  async addSummaryContent(doc, report, project) {
    doc.fontSize(14).font('Helvetica-Bold').text('Summary', this.margin, doc.y);
    doc.moveDown(0.5);
    doc.fontSize(10).font('Helvetica');

    if (report.content?.summary) {
      doc.text(report.content.summary, this.margin, doc.y, {
        width: this.pageWidth - (2 * this.margin),
        align: 'justify'
      });
      doc.moveDown();
    }

    // Key points
    if (report.content?.keyPoints) {
      doc.fontSize(12).font('Helvetica-Bold').text('Key Points', this.margin);
      doc.moveDown(0.5);
      doc.fontSize(10).font('Helvetica');

      const points = report.content.keyPoints.split('\n');
      for (const point of points) {
        if (point.trim()) {
          doc.text(`• ${point.trim()}`, this.margin + 10);
        }
      }
      doc.moveDown();
    }

    // Media section
    await this.addMediaSection(doc, report);
  }

  /**
   * Add daily log content
   */
  async addDailyLogContent(doc, report, project) {
    doc.fontSize(14).font('Helvetica-Bold').text('Daily Activities', this.margin, doc.y);
    doc.moveDown(0.5);
    doc.fontSize(10).font('Helvetica');

    // Work performed
    if (report.content?.workPerformed) {
      doc.fontSize(12).font('Helvetica-Bold').text('Work Performed', this.margin);
      doc.moveDown(0.5);
      doc.fontSize(10).font('Helvetica');
      doc.text(report.content.workPerformed, this.margin + 10);
      doc.moveDown();
    }

    // Weather conditions
    if (report.metadata?.weather) {
      doc.fontSize(12).font('Helvetica-Bold').text('Weather Conditions', this.margin);
      doc.moveDown(0.5);
      doc.fontSize(10).font('Helvetica');
      doc.text(`Temperature: ${report.metadata.weather.temperature}°F`, this.margin + 10);
      doc.text(`Conditions: ${report.metadata.weather.conditions}`, this.margin + 10);
      doc.moveDown();
    }

    // Tomorrow's plan
    if (report.content?.tomorrowPlan) {
      doc.fontSize(12).font('Helvetica-Bold').text("Tomorrow's Plan", this.margin);
      doc.moveDown(0.5);
      doc.fontSize(10).font('Helvetica');
      
      const tasks = report.content.tomorrowPlan.split('\n');
      for (const task of tasks) {
        if (task.trim()) {
          doc.text(`□ ${task.trim()}`, this.margin + 10);
        }
      }
      doc.moveDown();
    }

    // Media section
    await this.addMediaSection(doc, report);
  }

  /**
   * Add media section with thumbnails
   */
  async addMediaSection(doc, report) {
    if (!report.metadata?.mediaIds || report.metadata.mediaIds.length === 0) {
      return;
    }

    // Check if we need a new page
    if (doc.y > this.pageHeight - 200) {
      doc.addPage();
    }

    doc.fontSize(12).font('Helvetica-Bold').text('Documentation', this.margin);
    doc.moveDown(0.5);

    // Get media items
    const media = await prisma.media.findMany({
      where: {
        id: { in: report.metadata.mediaIds }
      },
      include: {
        user: true
      },
      orderBy: { timestamp: 'desc' }
    });

    // Add media grid (3 columns)
    const colWidth = (this.pageWidth - (2 * this.margin) - 20) / 3;
    let x = this.margin;
    let y = doc.y;
    let col = 0;

    for (const item of media) {
      // Check if we need a new page
      if (y > this.pageHeight - 150) {
        doc.addPage();
        y = this.margin + 80;
        x = this.margin;
        col = 0;
      }

      // Media placeholder box
      doc.rect(x, y, colWidth, colWidth).stroke();
      
      // Media type indicator
      doc.fontSize(8).font('Helvetica');
      const typeText = item.mediaType === 'VIDEO' ? 'VIDEO' : 'PHOTO';
      doc.text(typeText, x + 5, y + 5);

      // User and timestamp
      doc.fontSize(7);
      doc.text(item.user.name, x + 5, y + colWidth - 20, { width: colWidth - 10 });
      doc.text(format(new Date(item.timestamp), 'MM/dd HH:mm'), x + 5, y + colWidth - 10, { width: colWidth - 10 });

      // Notes if available
      if (item.notes) {
        doc.fontSize(6);
        doc.text(item.notes.substring(0, 50) + '...', x + 5, y + 20, { 
          width: colWidth - 10,
          height: 40
        });
      }

      // Move to next position
      col++;
      if (col >= 3) {
        col = 0;
        x = this.margin;
        y += colWidth + 20;
      } else {
        x += colWidth + 10;
      }
    }

    doc.y = y + colWidth + 20;
  }

  /**
   * Add footer to all pages
   */
  addFooter(doc, project) {
    const pageCount = doc.bufferedPageRange().count;
    
    for (let i = 0; i < pageCount; i++) {
      doc.switchToPage(i);
      
      // Footer line
      doc.moveTo(this.margin, this.pageHeight - 60)
         .lineTo(this.pageWidth - this.margin, this.pageHeight - 60)
         .stroke();
      
      // Footer text
      doc.fontSize(8).font('Helvetica');
      doc.text(
        `Generated by FSW Iron Task | ${project.company.name}`,
        this.margin,
        this.pageHeight - 50,
        { width: 200, align: 'left' }
      );
      
      doc.text(
        `Page ${i + 1} of ${pageCount}`,
        this.pageWidth - 150,
        this.pageHeight - 50,
        { width: 100, align: 'right' }
      );
    }
  }

  /**
   * Get media statistics for a project
   */
  async getMediaStats(projectId, dateRange) {
    const where = {
      projectId,
      ...(dateRange && {
        timestamp: {
          gte: dateRange.start ? new Date(dateRange.start) : undefined,
          lte: dateRange.end ? new Date(dateRange.end) : undefined
        }
      })
    };

    const [photos, videos, users] = await Promise.all([
      prisma.media.count({ where: { ...where, mediaType: 'PHOTO' } }),
      prisma.media.count({ where: { ...where, mediaType: { in: ['VIDEO', 'DUAL_VIDEO'] } } }),
      prisma.media.groupBy({
        by: ['userId'],
        where,
        _count: true
      })
    ]);

    return {
      photos,
      videos,
      activeUsers: users.length
    };
  }

  /**
   * Save PDF to file system
   */
  async savePDF(buffer, filename) {
    const dir = path.join(process.cwd(), 'reports');
    
    // Create directory if it doesn't exist
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    const filepath = path.join(dir, filename);
    await fs.promises.writeFile(filepath, buffer);
    
    return filepath;
  }
}

module.exports = new PDFReportService();