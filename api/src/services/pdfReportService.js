const PDFDocument = require('pdfkit')
const fs = require('fs')
const path = require('path')
const { format } = require('date-fns')
const prisma = require('../lib/prisma')
const { logger } = require('../utils/logger')

class PDFReportService {
  constructor() {
    this.pageWidth = 612 // Letter size
    this.pageHeight = 792
    this.margin = 50
  }

  /**
   * Generate a PDF report
   * @param {Object} report - Report data from database
   * @param {Object} options - Generation options
   * @returns {Promise<Buffer>} PDF buffer
   */
  async generatePDF(report, options = {}) {
    return new Promise(async (resolve, reject) => {
      try {
        const doc = this.createPDFDocument(report)
        const chunks = this.setupPDFDataCollection(doc, resolve)
        const { project, user } = await this.fetchReportData(report)
        
        this.buildPDFContent(doc, report, project, user)
        
        doc.end()
      } catch (error) {
        logger.error('Failed to generate PDF:', error)
        reject(error)
      }
    })
  }

  /**
   * Create PDF document with configuration
   */
  createPDFDocument(report) {
    return new PDFDocument({
      size: 'letter',
      margins: {
        top: this.margin,
        bottom: this.margin,
        left: this.margin,
        right: this.margin,
      },
      info: {
        Title: report.title,
        Author: 'FSW Iron Task',
        Subject: `${report.reportType} Report`,
        Keywords: 'construction,documentation,steel',
        CreationDate: new Date(),
      },
    })
  }

  /**
   * Setup PDF data collection
   */
  setupPDFDataCollection(doc, resolve) {
    const chunks = []
    doc.on('data', chunk => chunks.push(chunk))
    doc.on('end', () => resolve(Buffer.concat(chunks)))
    return chunks
  }

  /**
   * Fetch required data for PDF generation
   */
  async fetchReportData(report) {
    const [project, user] = await Promise.all([
      prisma.project.findUnique({
        where: { id: report.projectId },
        include: {
          company: true,
          projectMembers: {
            include: { user: true },
          },
        },
      }),
      prisma.user.findUnique({
        where: { id: report.userId },
      })
    ])
    
    return { project, user }
  }

  /**
   * Build complete PDF content
   */
  async buildPDFContent(doc, report, project, user) {
    this.addHeader(doc, project, report)
    this.addProjectInfo(doc, project, report)
    await this.addReportTypeSpecificContent(doc, report, project)
    this.addFooter(doc, project)
  }

  /**
   * Add content based on report type
   */
  async addReportTypeSpecificContent(doc, report, project) {
    switch (report.reportType) {
      case 'PROGRESS_RECAP':
        await this.addProgressRecapContent(doc, report, project)
        break
      case 'SUMMARY':
        await this.addSummaryContent(doc, report, project)
        break
      case 'DAILY_LOG':
        await this.addDailyLogContent(doc, report, project)
        break
    }
  }

  /**
   * Add header to PDF
   */
  addHeader(doc, project, report) {
    // Company logo placeholder
    doc.rect(this.margin, this.margin, 80, 40).stroke()
    doc.fontSize(10).text('LOGO', this.margin + 30, this.margin + 15)

    // Company name and report title
    doc.fontSize(20).text(project.company.name, 150, this.margin, {
      width: 400,
      align: 'center',
    })

    doc.fontSize(16).text(report.title, 150, this.margin + 25, {
      width: 400,
      align: 'center',
    })

    // Line separator
    doc
      .moveTo(this.margin, this.margin + 60)
      .lineTo(this.pageWidth - this.margin, this.margin + 60)
      .stroke()

    doc.moveDown(3)
  }

  /**
   * Add project information section
   */
  addProjectInfo(doc, project, report) {
    const y = doc.y

    doc
      .fontSize(14)
      .font('Helvetica-Bold')
      .text('Project Information', this.margin, y)
    doc.moveDown(0.5)

    const infoY = doc.y
    doc.fontSize(10).font('Helvetica')

    // Left column
    doc.text(`Project: ${project.name}`, this.margin, infoY)
    doc.text(`Job Number: ${project.jobNumber}`, this.margin, infoY + 15)
    doc.text(`Location: ${project.location}`, this.margin, infoY + 30)

    // Right column
    doc.text(`Status: ${project.status}`, 300, infoY)
    doc.text(
      `Report Date: ${format(new Date(report.createdAt), 'MM/dd/yyyy')}`,
      300,
      infoY + 15
    )
    doc.text(`Generated By: ${report.user?.name || 'System'}`, 300, infoY + 30)

    doc.y = infoY + 50

    // Line separator
    doc
      .moveTo(this.margin, doc.y)
      .lineTo(this.pageWidth - this.margin, doc.y)
      .stroke()

    doc.moveDown(2)
  }

  /**
   * Add progress recap content
   */
  async addProgressRecapContent(doc, report, project) {
    await this.addProgressOverviewSection(doc, report)
    this.addActivitiesSummarySection(doc, report)
    this.addKeyAccomplishmentsSection(doc, report)
    this.addSafetyNotesSection(doc, report)
    await this.addMediaSection(doc, report)
  }

  /**
   * Add progress overview section
   */
  async addProgressOverviewSection(doc, report) {
    doc
      .fontSize(14)
      .font('Helvetica-Bold')
      .text('Progress Overview', this.margin, doc.y)
    doc.moveDown(0.5)
    doc.fontSize(10).font('Helvetica')

    const mediaStats = await this.getMediaStats(
      report.projectId,
      report.metadata?.dateRange
    )

    doc.text(`Total Photos: ${mediaStats.photos}`, this.margin)
    doc.text(`Total Videos: ${mediaStats.videos}`, this.margin)
    doc.text(`Team Members Active: ${mediaStats.activeUsers}`, this.margin)
    doc.moveDown()
  }

  /**
   * Add activities summary section
   */
  addActivitiesSummarySection(doc, report) {
    if (!report.metadata?.activities) return

    doc
      .fontSize(12)
      .font('Helvetica-Bold')
      .text('Activities Summary', this.margin)
    doc.moveDown(0.5)
    doc.fontSize(10).font('Helvetica')

    for (const activity of report.metadata.activities) {
      doc.text(
        `• ${activity.type}: ${activity.count} items`,
        this.margin + 10
      )
    }
    doc.moveDown()
  }

  /**
   * Add key accomplishments section
   */
  addKeyAccomplishmentsSection(doc, report) {
    if (!report.content?.accomplishments) return

    doc
      .fontSize(12)
      .font('Helvetica-Bold')
      .text('Key Accomplishments', this.margin)
    doc.moveDown(0.5)
    doc.fontSize(10).font('Helvetica')

    const accomplishments = report.content.accomplishments.split('\n')
    for (const item of accomplishments) {
      if (item.trim()) {
        doc.text(`• ${item.trim()}`, this.margin + 10)
      }
    }
    doc.moveDown()
  }

  /**
   * Add safety notes section
   */
  addSafetyNotesSection(doc, report) {
    if (!report.content?.safetyNotes) return

    doc.fontSize(12).font('Helvetica-Bold').text('Safety Notes', this.margin)
    doc.moveDown(0.5)
    doc.fontSize(10).font('Helvetica')
    doc.text(report.content.safetyNotes, this.margin + 10)
    doc.moveDown()
  }

  /**
   * Add summary content
   */
  async addSummaryContent(doc, report, project) {
    doc.fontSize(14).font('Helvetica-Bold').text('Summary', this.margin, doc.y)
    doc.moveDown(0.5)
    doc.fontSize(10).font('Helvetica')

    if (report.content?.summary) {
      doc.text(report.content.summary, this.margin, doc.y, {
        width: this.pageWidth - 2 * this.margin,
        align: 'justify',
      })
      doc.moveDown()
    }

    // Key points
    if (report.content?.keyPoints) {
      doc.fontSize(12).font('Helvetica-Bold').text('Key Points', this.margin)
      doc.moveDown(0.5)
      doc.fontSize(10).font('Helvetica')

      const points = report.content.keyPoints.split('\n')
      for (const point of points) {
        if (point.trim()) {
          doc.text(`• ${point.trim()}`, this.margin + 10)
        }
      }
      doc.moveDown()
    }

    // Media section
    await this.addMediaSection(doc, report)
  }

  /**
   * Add daily log content
   */
  async addDailyLogContent(doc, report, project) {
    doc
      .fontSize(14)
      .font('Helvetica-Bold')
      .text('Daily Activities', this.margin, doc.y)
    doc.moveDown(0.5)
    doc.fontSize(10).font('Helvetica')

    // Work performed
    if (report.content?.workPerformed) {
      doc
        .fontSize(12)
        .font('Helvetica-Bold')
        .text('Work Performed', this.margin)
      doc.moveDown(0.5)
      doc.fontSize(10).font('Helvetica')
      doc.text(report.content.workPerformed, this.margin + 10)
      doc.moveDown()
    }

    // Weather conditions
    if (report.metadata?.weather) {
      doc
        .fontSize(12)
        .font('Helvetica-Bold')
        .text('Weather Conditions', this.margin)
      doc.moveDown(0.5)
      doc.fontSize(10).font('Helvetica')
      doc.text(
        `Temperature: ${report.metadata.weather.temperature}°F`,
        this.margin + 10
      )
      doc.text(
        `Conditions: ${report.metadata.weather.conditions}`,
        this.margin + 10
      )
      doc.moveDown()
    }

    // Tomorrow's plan
    if (report.content?.tomorrowPlan) {
      doc
        .fontSize(12)
        .font('Helvetica-Bold')
        .text("Tomorrow's Plan", this.margin)
      doc.moveDown(0.5)
      doc.fontSize(10).font('Helvetica')

      const tasks = report.content.tomorrowPlan.split('\n')
      for (const task of tasks) {
        if (task.trim()) {
          doc.text(`□ ${task.trim()}`, this.margin + 10)
        }
      }
      doc.moveDown()
    }

    // Media section
    await this.addMediaSection(doc, report)
  }

  /**
   * Add media section with thumbnails
   */
  async addMediaSection(doc, report) {
    if (!report.metadata?.mediaIds || report.metadata.mediaIds.length === 0) {
      return
    }

    this.prepareMediaSectionPage(doc)
    const media = await this.fetchMediaItems(report)
    this.renderMediaGrid(doc, media)
  }

  /**
   * Prepare page for media section
   */
  prepareMediaSectionPage(doc) {
    // Check if we need a new page
    if (doc.y > this.pageHeight - 200) {
      doc.addPage()
    }

    doc.fontSize(12).font('Helvetica-Bold').text('Documentation', this.margin)
    doc.moveDown(0.5)
  }

  /**
   * Fetch media items for report
   */
  async fetchMediaItems(report) {
    return await prisma.media.findMany({
      where: {
        id: { in: report.metadata.mediaIds },
      },
      include: {
        user: true,
      },
      orderBy: { timestamp: 'desc' },
    })
  }

  /**
   * Render media items in a grid layout
   */
  renderMediaGrid(doc, media) {
    const colWidth = (this.pageWidth - 2 * this.margin - 20) / 3
    let x = this.margin
    let y = doc.y
    let col = 0

    for (const item of media) {
      const gridPosition = this.calculateGridPosition(y, col, colWidth)
      
      // Check if we need a new page
      if (gridPosition.needsNewPage) {
        doc.addPage()
        y = this.margin + 80
        x = this.margin
        col = 0
      }

      this.renderMediaItem(doc, item, x, y, colWidth)

      // Move to next position
      const nextPosition = this.getNextGridPosition(col, x, y, colWidth)
      col = nextPosition.col
      x = nextPosition.x
      y = nextPosition.y
    }

    doc.y = y + colWidth + 20
  }

  /**
   * Calculate grid position and check if new page needed
   */
  calculateGridPosition(y, col, colWidth) {
    return {
      needsNewPage: y > this.pageHeight - 150
    }
  }

  /**
   * Render individual media item
   */
  renderMediaItem(doc, item, x, y, colWidth) {
    // Media placeholder box
    doc.rect(x, y, colWidth, colWidth).stroke()

    // Media type indicator
    doc.fontSize(8).font('Helvetica')
    const typeText = item.mediaType === 'VIDEO' ? 'VIDEO' : 'PHOTO'
    doc.text(typeText, x + 5, y + 5)

    // User and timestamp
    doc.fontSize(7)
    doc.text(item.user.name, x + 5, y + colWidth - 20, {
      width: colWidth - 10,
    })
    doc.text(
      format(new Date(item.timestamp), 'MM/dd HH:mm'),
      x + 5,
      y + colWidth - 10,
      { width: colWidth - 10 }
    )

    // Notes if available
    if (item.notes) {
      doc.fontSize(6)
      doc.text(item.notes.substring(0, 50) + '...', x + 5, y + 20, {
        width: colWidth - 10,
        height: 40,
      })
    }
  }

  /**
   * Calculate next grid position
   */
  getNextGridPosition(col, x, y, colWidth) {
    col++
    if (col >= 3) {
      return {
        col: 0,
        x: this.margin,
        y: y + colWidth + 20
      }
    } else {
      return {
        col,
        x: x + colWidth + 10,
        y
      }
    }
  }

  /**
   * Add footer to all pages
   */
  addFooter(doc, project) {
    const pageCount = doc.bufferedPageRange().count

    for (let i = 0; i < pageCount; i++) {
      doc.switchToPage(i)

      // Footer line
      doc
        .moveTo(this.margin, this.pageHeight - 60)
        .lineTo(this.pageWidth - this.margin, this.pageHeight - 60)
        .stroke()

      // Footer text
      doc.fontSize(8).font('Helvetica')
      doc.text(
        `Generated by FSW Iron Task | ${project.company.name}`,
        this.margin,
        this.pageHeight - 50,
        { width: 200, align: 'left' }
      )

      doc.text(
        `Page ${i + 1} of ${pageCount}`,
        this.pageWidth - 150,
        this.pageHeight - 50,
        { width: 100, align: 'right' }
      )
    }
  }

  /**
   * Get media statistics for a project
   */
  async getMediaStats(projectId, dateRange) {
    const where = {
      projectId,
      ...(dateRange && {
        timestamp: {
          gte: dateRange.start ? new Date(dateRange.start) : undefined,
          lte: dateRange.end ? new Date(dateRange.end) : undefined,
        },
      }),
    }

    const [photos, videos, users] = await Promise.all([
      prisma.media.count({ where: { ...where, mediaType: 'PHOTO' } }),
      prisma.media.count({
        where: { ...where, mediaType: { in: ['VIDEO', 'DUAL_VIDEO'] } },
      }),
      prisma.media.groupBy({
        by: ['userId'],
        where,
        _count: true,
      }),
    ])

    return {
      photos,
      videos,
      activeUsers: users.length,
    }
  }

  /**
   * Save PDF to file system
   */
  async savePDF(buffer, filename) {
    const dir = path.join(process.cwd(), 'reports')

    // Create directory if it doesn't exist
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true })
    }

    const filepath = path.join(dir, filename)
    await fs.promises.writeFile(filepath, buffer)

    return filepath
  }
}

module.exports = new PDFReportService()
